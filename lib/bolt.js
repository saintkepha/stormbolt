// Generated by CoffeeScript 1.4.0
(function() {
  var StormAgent, StormBolt,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

  StormAgent = require('stormagent');

  StormBolt = (function(_super) {
    var MuxDemux, async, extend, fs, http, schema, tls, url, validate;

    __extends(StormBolt, _super);

    validate = require('json-schema').validate;

    tls = require("tls");

    fs = require("fs");

    http = require("http");

    url = require('url');

    MuxDemux = require('mux-demux');

    async = require('async');

    extend = require('util')._extend;

    schema = {
      name: "storm",
      type: "object",
      additionalProperties: true,
      properties: {
        cert: {
          type: "any",
          required: true
        },
        key: {
          type: "any",
          required: true
        },
        ca: {
          type: "any",
          required: true
        },
        uplinks: {
          type: "array"
        },
        uplinkStrategy: {
          type: "string"
        },
        allowRelay: {
          type: "boolean"
        },
        relayPort: {
          type: "integer"
        },
        allowedPorts: {
          type: "array"
        },
        listenPort: {
          type: "integer"
        },
        beaconInterval: {
          type: "integer"
        },
        beaconRetry: {
          type: "integer"
        }
      }
    };

    function StormBolt(config) {
      var connections,
        _this = this;
      StormBolt.__super__.constructor.call(this, config);
      this["import"](module);
      this.repeatInterval = 5;
      this.connections = connections = {};
      this.on('server.connect', function(cname, stream, mx) {
        var bstream, capability;
        _this.log("server connect event triggered for cname - " + cname);
        capability = mx.createReadStream('capability');
        capability.on('data', function(capa) {
          var _ref;
          _this.log("received capability info from client:", capa);
          connections[cname] = {
            stream: stream,
            mux: mx,
            allowedPorts: (_ref = capa.split(',')) != null ? _ref : [],
            validity: _this.config.beaconValidity
          };
          return _this.log("Added new client in the connections list, cname - " + cname);
        });
        bstream = mx.createStream('beacon', {
          allowHalfOpen: true
        });
        return bstream.on('data', function(beacon) {
          _this.log("received beacon from client: " + cname);
          connections[cname].validity = _this.config.beaconValidity;
          return bstream.write("beacon:reply");
        });
      });
      this.on('server.disconnect', function(cname, stream, mx) {
        _this.log("server disconnect event triggered for cname - " + cname);
        mx.close();
        return connections[cname] = null;
      });
    }

    StormBolt.prototype.status = function() {
      var state, _ref;
      state = StormBolt.__super__.status.apply(this, arguments);
      state.uplink = (_ref = this.uplink) != null ? _ref : null;
      state.clients = this.clients();
      return state;
    };

    StormBolt.prototype.run = function(config) {
      var ca, cacert, chain, connected, i, line, res, retries, running, server, _i, _len, _ref,
        _this = this;
      if (config != null) {
        this.log('run called with:', config);
        res = validate(config, schema);
        this.log('run - validation of runtime config:', res);
        if (res.valid) {
          this.config = extend(this.config, config);
        }
      }
      StormBolt.__super__.run.call(this, config);
      try {
        this.log('run - validating security credentials...');
        if (!(this.config.cert instanceof Buffer)) {
          this.config.cert = fs.readFileSync("" + this.config.cert, 'utf8');
        }
        if (!(this.config.key instanceof Buffer)) {
          this.config.key = fs.readFileSync("" + this.config.key, 'utf8');
        }
        if (!(this.config.ca instanceof Buffer)) {
          ca = [];
          chain = fs.readFileSync("" + this.config.ca, 'utf8');
          chain = chain.split("\n");
          cacert = [];
          for (_i = 0, _len = chain.length; _i < _len; _i++) {
            line = chain[_i];
            if (!(line.length !== 0)) {
              continue;
            }
            cacert.push(line);
            if (line.match(/-END CERTIFICATE-/)) {
              ca.push(cacert.join("\n"));
              cacert = [];
            }
          }
          this.config.ca = ca;
        }
      } catch (err) {
        this.log("run - missing proper security credentials, attempting to self-configure...");
        this.activate(null, function(err, storm) {
          if (!err) {
            _this.on("error", function(err) {
              return _this.log("run - bolt fizzled... should do something smart here");
            });
            return _this.run(storm.bolt);
          }
        });
        return;
      }
      if ((this.config.listenPort != null) && this.config.listenPort > 0) {
        server = this.listen(this.config.listenPort, {
          key: this.config.key,
          cert: this.config.cert,
          ca: this.config.ca,
          requestCert: true,
          rejectUnauthorized: true
        });
        running = true;
        async.whilst(function() {
          return running;
        }, function(repeat) {
          var entry, key, _fn, _ref;
          _ref = _this.connections;
          _fn = function(key, entry) {
            if (!((entry != null) && (entry.mux != null) && (entry.stream != null))) {
              return;
            }
            _this.log("DEBUG: " + key + " has validity=" + entry.validity);
            _this.connections[key].validity -= _this.repeatInterval;
            if (!(entry.validity > 1)) {
              try {
                entry.mux.close();
                entry.stream.destroy();
              } catch (err) {
                _this.log("unable to properly terminate expired client connection: " + err);
              }
              delete _this.connections[key];
              return _this.log("removed expired client connection from " + key);
            }
          };
          for (key in _ref) {
            entry = _ref[key];
            _fn(key, entry);
          }
          return setTimeout(repeat, _this.repeatInterval * 1000);
        }, function(err) {
          return _this.log("bolt server no longer running, validity checker stopping...");
        });
        server.on('error', function(err) {
          _this.log("fatal issue with bolt server: " + err);
          running = false;
          return _this.emit('server.error', err);
        });
      }
      if ((this.config.uplinks != null) && this.config.uplinks.length > 0) {
        _ref = [0, 0], i = _ref[0], retries = _ref[1];
        connected = false;
        this.on('client.connection', function(stream) {
          connected = true;
          return retries = 0;
        });
        this.on('client.disconnect', function(stream) {
          return connected = false;
        });
        async.forever(function(next) {
          var host, port, uplink, _ref1;
          if (retries > 30) {
            next(new Error("retry max exceeded, unable to establish bolt server connection"));
          }
          if (!connected) {
            uplink = _this.config.uplinks[i++];
            _ref1 = uplink.split(':'), host = _ref1[0], port = _ref1[1];
            _this.connect(host, port, {
              key: _this.config.key,
              cert: _this.config.cert,
              ca: _this.config.ca,
              requestCert: true
            });
            if (!(i < _this.config.uplinks.length)) {
              i = 0;
            }
          }
          return setTimeout(next, 5000);
        }, function(err) {
          if (err != null) {
            return _this.emit('error', err);
          }
        });
      }
      if (this.config.allowRelay) {
        return this.relay(this.config.relayPort);
      }
    };

    StormBolt.prototype.clients = function(key) {
      var entry, res, _ref, _results;
      if (key != null) {
        if (__indexOf.call(this.connections, key) < 0) {
          return;
        }
        entry = this.connections[key];
        if (entry == null) {
          return;
        }
        res = {
          cname: key,
          ports: entry.allowedPorts,
          address: entry.stream.remoteAddress,
          validity: entry.validity
        };
        return res;
      }
      _ref = this.connections;
      _results = [];
      for (key in _ref) {
        entry = _ref[key];
        if (entry != null) {
          _results.push({
            cname: key,
            ports: entry.allowedPorts,
            address: entry.stream.remoteAddress,
            validity: entry.validity
          });
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    StormBolt.prototype.relay = function(port) {
      var acceptor,
        _this = this;
      if (!((port != null) && port > 0)) {
        this.log("need to pass in valid port for performing relay");
        return;
      }
      this.log('starting the relay on port ' + port);
      acceptor = http.createServer().listen(port);
      return acceptor.on("request", function(request, response) {
        var body, cname, entry, error, key, relay, relayResponse, res, target, _ref, _ref1;
        if (request.url === '/cname') {
          res = [];
          _ref = _this.connections;
          for (key in _ref) {
            entry = _ref[key];
            if (entry != null) {
              res.push({
                cname: key,
                ports: entry.allowedPorts,
                address: entry.stream.remoteAddress,
                validity: entry.validity
              });
            }
          }
          body = JSON.stringify(res);
          _this.log("[proxy] returning connections data: " + body);
          response.writeHead(200, {
            'Content-Length': body.length,
            'Content-Type': 'application/json'
          });
          response.end(body, "utf8");
          return;
        }
        target = request.headers['stormflash-bolt-target'];
        if (target) {
          _ref1 = target.split(':'), cname = _ref1[0], port = _ref1[1];
        }
        if (cname) {
          _this.log("active client connections:", _this.clients);
          entry = _this.connections[cname];
          if (!entry) {
            error = "no such stormflash-bolt-target: " + target;
            _this.log("error:", error);
            response.writeHead(404, {
              'Content-Length': error.length,
              'Content-Type': 'application/json',
              'Connection': 'close'
            });
            response.end(error, "utf8");
            return;
          }
          _this.log("[proxy] forwarding request to " + cname + " at " + entry.stream.remoteAddress);
          if (entry.mux) {
            relay = entry.mux.createStream('relay:' + port, {
              allowHalfOpen: true
            });
            relay.write(JSON.stringify({
              method: request.method,
              url: request.url,
              headers: request.headers
            }));
            request.setEncoding('utf8');
            request.pipe(relay);
            relayResponse = null;
            relay.on("data", function(chunk) {
              if (!relayResponse) {
                try {
                  _this.log("relay response received: " + chunk);
                  relayResponse = JSON.parse(chunk);
                  response.writeHead(relayResponse.statusCode, relayResponse.headers);
                  return relay.pipe(response);
                } catch (err) {
                  _this.log("invalid relay response!");
                  relay.end();
                }
              }
            });
            relay.on("end", function() {
              return _this.log("no more data in relay");
            });
            request.on("data", function(chunk) {
              return _this.log("read some data: " + chunk);
            });
            return request.on("end", function() {
              return _this.log("no more data in the request...");
            });
          }
        }
      });
    };

    StormBolt.prototype.listen = function(port, options) {
      var server,
        _this = this;
      this.log("server port:" + port);
      server = tls.createServer(options, function(stream) {
        var certObj, cname, _ref;
        try {
          _this.log("TLS connection established with VCG client from: " + stream.remoteAddress);
          _this.log('Debugging null certs issue : server authorizationError: ' + stream.authorizationError);
          certObj = stream.getPeerCertificate();
          cname = certObj.subject.CN;
          stream.name = cname;
          server.emit('newconnection', cname, stream);
          return _this.log((_ref = 'server connected ' + stream.authorized) != null ? _ref : {
            'authorized': 'unauthorized'
          });
        } catch (error) {
          _this.log('unable to retrieve peer certificate and authorize connection!');
          stream.end();
        }
      });
      server.on('newconnection', function(cname, stream) {
        var mx;
        _this.log('connection event triggered for: ' + cname);
        stream.pipe(mx = MuxDemux()).pipe(stream);
        _this.emit('server.connect', cname, stream, mx);
        stream.on("close", function() {
          _this.log("Bolt client connection is closed for ID: " + stream.name);
          return _this.emit('server.disconnect', cname, stream, mx);
        });
        stream.on('error', function() {
          return mx.destroy();
        });
        return mx.on('error', function() {
          return stream.destroy();
        });
      });
      server.on('error', function(err) {
        var message;
        _this.log('server connection error :' + err.message);
        try {
          message = String(err.message);
          if ((message.indexOf('ECONNRESET')) >= 0) {
            _this.log('throw error: ' + 'ECONNRESET');
            throw new Error(err);
          }
        } catch (e) {
          return _this.log('error e' + e);
        }
      });
      server.listen(port);
      return server;
    };

    StormBolt.prototype.connect = function(host, port, options) {
      var calledReconnectOnce, stream,
        _this = this;
      tls.SLAB_BUFFER_SIZE = 100 * 1024;
      this.log("making connection to bolt server at: " + host + ':' + port);
      calledReconnectOnce = false;
      stream = tls.connect(port, host, options, function() {
        var forwardingPorts, mx;
        if (stream.authorized) {
          _this.log("Successfully connected to bolt server");
          _this.uplink = {
            host: host,
            port: port,
            options: options
          };
        } else {
          _this.log("Failed to authorize TLS connection. Could not connect to bolt server (ignored for now)");
        }
        _this.emit('client.connection', stream);
        stream.setKeepAlive(true, 60 * 1000);
        stream.setEncoding('utf8');
        stream.pipe(mx = MuxDemux()).pipe(stream);
        forwardingPorts = _this.config.allowedPorts;
        return mx.on("connection", function(_stream) {
          var action, breply, bsent, incoming, request, target, _ref, _ref1;
          _ref = _stream.meta.split(':'), action = _ref[0], target = _ref[1];
          _this.log("Client: action " + action + "  target " + target);
          _stream.on('error', function(err) {
            return _this.log(("Client: mux stream for " + _stream.meta + " has error: ") + err);
          });
          switch (action) {
            case 'capability':
              _this.log('sending capability information...');
              _stream.write(forwardingPorts.join(','));
              return _stream.end();
            case 'beacon':
              _ref1 = [0, 0], bsent = _ref1[0], breply = _ref1[1];
              _stream.on('data', function(data) {
                breply++;
                return _this.log("received beacon reply: " + data);
              });
              _this.log('sending beacons...');
              return async.whilst(function() {
                return bsent - breply < _this.config.beaconRetry;
              }, function(repeat) {
                _this.log("sending beacon...");
                _stream.write("Beacon");
                bsent++;
                return setTimeout(repeat, _this.config.beaconInterval * 1000);
              }, function(err) {
                if (err == null) {
                  err = "beacon retry timeout, server no longer responding";
                }
                _this.log("final call on sending beacons, exiting with: " + (err != null ? err : "no errors"));
                try {
                  _stream.end();
                  mx.destroy();
                  return stream.end();
                } catch (err) {
                  return _this.log("error during client connection shutdown due to beacon timeout: " + err);
                }
              });
            case 'relay':
              target = Number(target);
              if (__indexOf.call(forwardingPorts, target) < 0) {
                _this.log("request for relay to unsupported target port: " + target);
                _stream.end();
                break;
              }
              incoming = '';
              request = null;
              _stream.on('data', function(chunk) {
                if (!request) {
                  try {
                    _this.log("request received: " + chunk);
                    return request = JSON.parse(chunk);
                  } catch (err) {
                    _this.log("invalid relay request!");
                    return _stream.end();
                  }
                } else {
                  _this.log("received some data: " + chunk);
                  return incoming += chunk;
                }
              });
              return _stream.on('end', function() {
                var relay, roptions, timeout;
                _this.log("relaying following request to local:" + target + " - ");
                roptions = url.parse(request.url);
                roptions.method = request.method;
                roptions.headers = request.headers;
                roptions.agent = false;
                roptions.port = target;
                _this.log(JSON.stringify(roptions));
                timeout = false;
                relay = http.request(roptions, function(reply) {
                  if (!timeout) {
                    _this.log("sending back reply");
                    reply.setEncoding('utf8');
                    try {
                      _stream.write(JSON.stringify({
                        statusCode: reply.statusCode,
                        headers: reply.headers
                      }));
                      return reply.pipe(_stream, {
                        end: true
                      });
                    } catch (err) {
                      return _this.log("unable to write response back to requestor upstream bolt! error: " + err);
                    }
                  }
                });
                if (incoming) {
                  relay.write(incoming);
                }
                relay.end();
                relay.on('end', function() {
                  return _this.log("no more data");
                });
                relay.setTimeout(20000, function() {
                  _this.log("error during performing relay action! request timedout.");
                  timeout = true;
                  try {
                    _stream.write(JSON.stringify({
                      statusCode: 408,
                      headers: null
                    }));
                    _stream.end();
                  } catch (err) {
                    _this.log("unable to write response code back to requestor upstream bolt! error: " + err);
                  }
                  return _this.log("[relay request timed out, sending 408]");
                });
                return relay.on('error', function(err) {
                  _this.log("[relay request failed with following error]");
                  _this.log(err);
                  try {
                    _stream.write(JSON.stringify({
                      statusCode: 500,
                      headers: null
                    }));
                    _stream.end();
                  } catch (err) {
                    _this.log("unable to write response code back to requestor upstream bolt! error: " + err);
                  }
                  return _this.log("[relay request error, sending 500]");
                });
              });
            default:
              _this.log("unsupported action/target supplied by mux connection: " + action + "/" + target);
              return _stream.end();
          }
        });
      });
      stream.on("error", function(err) {
        _this.log(("client error during connection to " + host + ":" + port + " with: ") + err);
        return _this.emit('client.disconnect', stream);
      });
      stream.on("close", function() {
        _this.log("client closed connection to: " + host + ":" + port);
        return _this.emit('client.disconnect', stream);
      });
      return stream;
    };

    return StormBolt;

  })(StormAgent);

  module.exports = StormBolt;

}).call(this);
